#include <stdio.h>
#include <stdlib.h>

float DigFil(invar)
float invar;
/******************************************************************************/
/* Filter Solutions Version 2014                 Nuhertz Technologies, L.L.C. */
/*                                                            www.nuhertz.com */
/*                                                            +1 602-279-2448 */
/* 1st Order High Pass Butterworth                                            */
/* Bilinear Transformation with no Prewarping                                 */
/* Sample Frequency = 6.000 KHz                                               */
/* Standard Form                                                              */
/* Arithmetic Precision = 4 Digits                                            */
/*                                                                            */
/* Pass Band Frequency = 20.00 Hz                                             */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Input Variable Definitions:                                                */
/* Inputs:                                                                    */
/*   invar    float       The input to the filter                             */
/*                                                                            */
/* Option Selections:                                                         */
/* Standard C;   Not Initializable;        Internal States;   Optimized;      */
/*                                                                            */
/* There is no requirement to ever initialize the filter.                     */
/* The default initialization is zero when the filter is first called         */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* This software is automatically generated by Filter Solutions               */
/* no restrictions from Nuhertz Technologies, L.L.C. regarding the use and    */
/* distributions of this software.                                            */
/*                                                                            */
/******************************************************************************/

{
    float sumnum=0.0, sumden=0.0;  int i=0;
    static float states[1] = {0.0};
    static float znum[2] = {
        -.9896,
        .9896
    };
    static float zden[1] = {
        -.9793
    };
    sumnum = sumden = 0.0;
    sumden += states[0]*zden[0];
    sumnum += states[0]*znum[0];
    states[0] = invar-sumden;
    sumnum += states[0]*znum[1];
    return sumnum;
}



/* EXAMPLE
riff_header='RIFF',
wav_size=size of wave portion
wave_header="WAVE"
fmt_header="fmt"
fmt_chunk_size=16
audio_format=1
num_channels=1
sample_rate=44100
byte_rate=88200
sample_alignment=2
bit_depth=16
data_header="data"
data_bytes=15987456
*/
typedef struct wav_header {
    // RIFF Header
    char riff_header[4]; // Contains "RIFF"
    int wav_size; // Size of the wav portion of the file, which follows the first 8 bytes. File size - 8
    char wave_header[4]; // Contains "WAVE"
    
    // Format Header
    char fmt_header[4]; // Contains "fmt " (includes trailing space)
    int fmt_chunk_size; // Should be 16 for PCM
    short audio_format; // Should be 1 for PCM. 3 for IEEE Float
    short num_channels;
    int sample_rate;
    int byte_rate; // Number of bytes per second. sample_rate * num_channels * Bytes Per Sample
    short sample_alignment; // num_channels * Bytes Per Sample
    short bit_depth; // Number of bits per sample
    /////
   
    // Data
    char data_header[4]; // Contains "data"
    int data_bytes; // Number of bytes in data. Number of samples * num_channels * sample byte size
    // uint8_t bytes[]; // Remainder of wave file is bytes
} wav_header;

/* run this program using the console pauser or add your own getch, system("pause") or input loop */
 
unsigned int streamIIRFilter128_v2(unsigned int bitOfStream, unsigned int* pToOutBuffer);
unsigned int streamIIRFilter64_v2(unsigned int bitOfStream, unsigned int* pToOutBuffer);
void filter64_v3(unsigned long long bitStream, unsigned int* buffer);
void filter128_v3(unsigned long long bitStream, unsigned int* buffer);
void decimateBlock(unsigned int* input,   short* output, unsigned int outputSize);

void filter128OfBlock(unsigned char* inputStream, unsigned int* outputData,unsigned int bytesOfStreamPerBlock);
void filter64OfBlock(unsigned char* inputStream, unsigned int* outputData,unsigned int bytesOfStreamPerBlock);

int main(int argc, char *argv[]) {
	FILE* myAudioFile;
	FILE* templateFile;
	FILE* bitStreamFile;
	FILE* filteredFile;	
	wav_header audio_header;
	float fl1,fl2;
	
		unsigned long long bitStreamBuffer[256];
		unsigned int filteredBuffer[8200];
		unsigned short waveBuffer[8292];
	unsigned long long  *auxPtrToBitStream;
	unsigned int  *auxPtrToFilteredBuffer;
	//amount of 32bit words per block 
    const unsigned int intWordsPerBlock = 8192;
    //amount of 64bit words of bitstream per block 
    const unsigned int bsLongPerBlock = 128;
    //
    unsigned long long bitStreamLength;
    unsigned int wholeBsLongBlocks = 0;
    //bitStreamBuffer = malloc( (bsLongPerBlock*8));
    ////filteredBuffer  = malloc((intWordsPerBlock*4));
     unsigned int fastIntAudioDataLength;
	//open template of WAVE file header into structure
	templateFile = fopen("wav_header","rb");
	fread(&audio_header, sizeof(wav_header), 1, templateFile);
    fclose(templateFile);
    //---------------DBG-{
 
    //-------------------DBG-}
    //open bs file
    bitStreamFile = fopen("stream1.bin","rb");
    //read bitstream file size
    fseek(bitStreamFile,0,SEEK_END);
    bitStreamLength = ftell(bitStreamFile);
    fseek(bitStreamFile,0,SEEK_SET);
    //how many whole blocks contains a bs file
    wholeBsLongBlocks = bitStreamLength / (bsLongPerBlock << 3); //mult by 8 
    //open temporaty file
    filteredFile = fopen("filtered","wb");
    
		
	     
	for (int a1=0; a1<wholeBsLongBlocks; a1++) {
		//initializing auxialary pointers
	     auxPtrToBitStream = bitStreamBuffer;
	     auxPtrToFilteredBuffer = filteredBuffer;
		//reading all the bs file by blocks
		//1)read chunk into input buffer
		fread(bitStreamBuffer,bsLongPerBlock,8,bitStreamFile);
		//2)iterate the block and processing data
		for (int y1=0; y1<bsLongPerBlock; y1++) {
		      //a) processing 64bits of BS
			  	filter128_v3(*auxPtrToBitStream, auxPtrToFilteredBuffer);
			  //b)increment pointers
			  auxPtrToBitStream++;
			  auxPtrToFilteredBuffer += 64;
		}
		
	
		//3)Save results (block) into temp file
		fwrite(filteredBuffer,intWordsPerBlock, 4, filteredFile);
		
	}
	 	
	 //calculating amount of 32-bit words in high speed data 384kHz
	 fastIntAudioDataLength = intWordsPerBlock * wholeBsLongBlocks;
	
	fclose(filteredFile);
	//open again in read only mode
	filteredFile = fopen("filtered","rb");
	//create audio file
	myAudioFile = fopen("processed.wav","wb");

	audio_header.byte_rate = 12000;
	audio_header.sample_rate = 6000;
	audio_header.data_bytes = (fastIntAudioDataLength >> 5); // divided by 64 and divided by 2 (because 16bit wave)
	//write wave header
	fwrite(&audio_header, sizeof(wav_header),1,myAudioFile);
	
	for ( unsigned int k = 0; k < fastIntAudioDataLength; ) { 
		//1)read block into memory
		fread (filteredBuffer, intWordsPerBlock, 4, filteredFile);
		//2)decimate block
		decimateBlock(filteredBuffer,waveBuffer, (intWordsPerBlock >> 6));
		//3) write block in wave file
		fwrite (waveBuffer,256,1,myAudioFile);
		k += intWordsPerBlock;
		
		
	}
	
	fclose(myAudioFile);
	fclose(filteredFile);
    ///free memory
    //free(bitStreamBuffer);
    //free(filteredBuffer);
	return 0;
}

void filter128OfBlock(unsigned char* inputStream, unsigned int* outputData,unsigned int bytesOfStreamPerBlock) {
	 
	unsigned char inByte=0;
	const char msk = 0x01;
	for (int a3=0; a3 < bytesOfStreamPerBlock; a3++) {
		inByte = *inputStream; 
		 
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			
	 
		inputStream++;
	}
}

void filter64OfBlock(unsigned char* inputStream, unsigned int* outputData,unsigned int bytesOfStreamPerBlock) {
	unsigned int* ptr = outputData; 
	unsigned char inByte=0;
	const char msk = 0x01;
	for (int a3=0; a3 < bytesOfStreamPerBlock; a3++) {
		inByte = *inputStream; 
		for (int a4=0; a4<8; a4++ ) {
			streamIIRFilter64_v2((unsigned int)(inByte & msk), ptr);
			inByte >>= 1;
			ptr++;
		}
		inputStream++;
	}
}

void decimateBlock(unsigned int* input,   short* output, unsigned int outputSize){
	float sample;
   for(;outputSize > 0;){
   	sample = (float)*input;
   	
  	*output = (short) DigFil(sample);
  	input += 64;
  	output++;
  	if(outputSize & 1 ){
  		
	  }
  	outputSize--;
  }
}
/**the filter get a chunk (64bit) of bit stream
 and store result (each bit) into 32bit array**/ 
void filter64_v3(unsigned long long bitStream, unsigned int* buffer){
	
	unsigned long long bitToProcess = 0;
	unsigned long long mask = 1;
	unsigned int acc =0;
	static unsigned long long window = 0; 
	short idx = 0;
		const unsigned int coefs[]={24,36,49,66,85,106,131,159,189,222,258,297,338,381,
	426,472,519,567,615,662,709,753,796,836,874,907,937,963,983,999,1010,1015,1015,
	1010,999,983,963,937,907,874,836,796,753,709,662,615,567,519,472,426,381,338,297,
	258,222,189,159,131,106,85,66,49,36,24};
	
	for (int bitCount=0; bitCount < 64; bitCount++) {
		//extracting low bit
	     bitToProcess = bitStream & 1;	
	     //shifting window
		window <<= 1;
		//apply new bit
	    window |= bitToProcess;
	    mask = 1;
	    idx = 0;
		acc = 0;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
				if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
				if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
				if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
				if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
				if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		//store result
		*buffer = acc;;
		//increment pointer (to point to next word)
		buffer++;
	
		//shift BitStr to have next bit al low bit for processing
		bitStream >>= 1;
	}
	   
	 
}

/**the filter get a chunk (64bit) of bit stream
 and store result (each bit) into 32bit array**/ 
void filter128_v3(unsigned long long bitStream, unsigned int* buffer){
	
	unsigned long long bitToProcess = 0;
	unsigned long long mask = 1;
	unsigned int acc =0;
	unsigned long long carry = 0;
	static unsigned long long windowLow = 0;
	static unsigned long long windowHigh = 0; 
	short idx = 0;
const unsigned int coefs[128]={1,2,4,6,8,11,14,17,21,26,31,37,44,52,61,71,82,94,108,122,
		138,156,174,194,216,238,262,287,313,341,369,399,430,461,493,526,560,594,628,663,697,
		732,767,801,834,868,900,931,962,991,1019,1046,1071,1094,1116,1136,1153,1169,1183,
		1195,1204,1210,1216,1218,1218,1216,1210,1204,1195,1183,1169,1153,1136,1116,1094,
		1071,1046,1019,991,962,931,900,868,834,801,767,732,697,663,628,594,560,526,493,
		461,430,399,369,341,313,287,262,238,216,194,174,156,138,122,108,94,82,71,61,52,
		44,37,31,26,21,17,14,11,8,6,4,2,1 };
	
	for (int bitCount=0; bitCount < 64; bitCount++) {
		//extracting low bit
	     bitToProcess = bitStream & 1;	
		//extracting high bit from low word
		carry = windowLow & 0x8000000000000000;
		carry >>= 63;
		//shift, apply to  high word 
		windowHigh <<= 1;
		windowHigh |= carry;
		//shift low window and apply bit from bit stream 
		windowLow <<= 1;
		windowLow |= bitToProcess;

	    mask = 1;
	    idx = 0;
		acc = 0;
		if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
			if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		///////////high word
		mask=1;
			if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		//store result
		*buffer = acc;
		//increment pointer (to point to next word)
		buffer++;
///???????????????????????????????????????????????????????????????????
		//shift BitStr to have next bit al low bit for processing
		bitStream >>= 1;
	}
	   
	 
}
 
 

/* 128 Tap Low Pass Kaiser                                                 
  Finite Impulse Response                                                     
  Sample Frequency = 384.0 KHz                                                
  Standard Form                                                               
  Arithmetic Precision = 4 Digits                                                                                                                          
  Pass Band Frequency = 3.000 KHz  */

unsigned int streamIIRFilter64_v2(unsigned int bitOfStream, unsigned int* pToOutBuffer){

	static unsigned long long bits = {0};
	unsigned int result=0;
	unsigned long long bitMask = 1;
 
	const unsigned int coefs[]={24,36,49,66,85,106,131,159,189,222,258,297,338,381,
	426,472,519,567,615,662,709,753,796,836,874,907,937,963,983,999,1010,1015,1015,
	1010,999,983,963,937,907,874,836,796,753,709,662,615,567,519,472,426,381,338,297,
	258,222,189,159,131,106,85,66,49,36,24};
	
		bitOfStream &= 0x00000001;
	    bits 	<<= 1;
	    bits |= bitOfStream;
	    for (int a=0; a<64; a++) {
		 
	    	if (bitMask & bits) {
	            result += coefs[a];		
			}
			bitMask <<= 1;
		}
		
		*pToOutBuffer = result;
		
		//printf("%X, %X \n",bits[0], bits[1]);
	//	printf("%d \n", result);
		
}

//converts bit-stream into 32-bit integer chunk of data
//This function save previous results in an static array
/* 128 Tap Low Pass Hamming                                                   
  Finite Impulse Response                                                     
  Sample Frequency = 384.0 KHz                                                
  Standard Form                                                               
  Arithmetic Precision = 4 Digits                                                                                                                          
  Pass Band Frequency = 3.000 KHz  */
  //sum all the coefs equals 65534
unsigned int streamIIRFilter128_v2(unsigned int bitOfStream, unsigned int* pToOutBuffer) {
	
	static unsigned long long bits0 = 0;
	static unsigned long long bits1 = 0;
	unsigned int counterIndex = 0;
	unsigned long long state = 0;
	
	unsigned int result=0;
	const unsigned int coefs[128]={1,2,4,6,8,11,14,17,21,26,31,37,44,52,61,71,82,94,108,122,
		138,156,174,194,216,238,262,287,313,341,369,399,430,461,493,526,560,594,628,663,697,
		732,767,801,834,868,900,931,962,991,1019,1046,1071,1094,1116,1136,1153,1169,1183,
		1195,1204,1210,1216,1218,1218,1216,1210,1204,1195,1183,1169,1153,1136,1116,1094,
		1071,1046,1019,991,962,931,900,868,834,801,767,732,697,663,628,594,560,526,493,
		461,430,399,369,341,313,287,262,238,216,194,174,156,138,122,108,94,82,71,61,52,
		44,37,31,26,21,17,14,11,8,6,4,2,1 };
		bitOfStream &= 0x00000001;
		
		//1) shifting high word
		bits1 <<= 1;
		//2)Is the MSB in low word = 1  ?
		 state  = bits0 & 0x8000000000000000; //extract MSB
		 state >>= 63; //move to LSB
		 bits1 |= state; //apply to high word
		 //3) shft low word and apply input bit-stream
		 bits0 <<= 1;
		 bits0 |= bitOfStream;
		//processing first 64bits
	 
		state = 1;
		for (int a=0; a<64; a++) {
	    	if (state & bits0) {
	            result += coefs[counterIndex];		
			}
			state <<= 1;
			counterIndex++;
		}
		//processing last 64bit
		state = 1;
		for (int b=0; b<64; b++) {
		 
	    	if (state & bits1) {
	            result += coefs[counterIndex];		
			}
			state <<= 1;
			counterIndex++;
		}
		
		*pToOutBuffer = result;
		
	 //	printf("%d \n", result );
//	printf("%llx, %llx \n",bits0,bits1);
		
}
