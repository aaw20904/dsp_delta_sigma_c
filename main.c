#include <stdio.h>
#include <stdlib.h>

float DigFil3K(invar)
float invar;
/******************************************************************************/
/* Filter Solutions Version 2014                 Nuhertz Technologies, L.L.C. */
/*                                                            www.nuhertz.com */
/*                                                            +1 602-279-2448 */
/* 128 Tap Low Pass Kaiser                                                    */
/* Finite Impulse Response                                                    */
/* Sample Frequency = 384.0 KHz                                               */
/* Standard Form                                                              */
/* Arithmetic Precision = 4 Digits                                            */
/*                                                                            */
/* Pass Band Frequency = 3.000 KHz                                            */
/*                                                                            */
/* Kaiser Constant = 5.000                                                    */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Input Variable Definitions:                                                */
/* Inputs:                                                                    */
/*   invar    float       The input to the filter                             */
/*                                                                            */
/* Option Selections:                                                         */
/* Standard C;   Not Initializable;        Internal States;   Not Optimized;  */
/*                                                                            */
/* There is no requirement to ever initialize the filter.                     */
/* The default initialization is zero when the filter is first called         */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* This software is automatically generated by Filter Solutions               */
/* no restrictions from Nuhertz Technologies, L.L.C. regarding the use and    */
/* distributions of this software.                                            */
/*                                                                            */
/******************************************************************************/

{
    float sumnum=0.0; int i=0;
    static float states[127] = {
        0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
        0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
    };
    static float znum[128] = {
        5.326e-06,1.955e-05,3.913e-05,6.485e-05,9.748e-05,1.378e-04,1.868e-04,2.451e-04,3.137e-04,3.935e-04,
        4.852e-04,5.897e-04,7.079e-04,8.404e-04,9.882e-04,1.152e-03,1.332e-03,1.529e-03,1.744e-03,1.976e-03,
        2.227e-03,2.497e-03,2.785e-03,3.093e-03,3.419e-03,3.763e-03,4.126e-03,4.506e-03,4.904e-03,5.318e-03,
        5.748e-03,6.193e-03,6.652e-03,7.123e-03,7.605e-03,8.098e-03,8.599e-03,9.106e-03,9.618e-03,1.013e-02,
        1.065e-02,1.117e-02,1.168e-02,1.219e-02,1.269e-02,1.319e-02,1.367e-02,1.414e-02,1.459e-02,1.503e-02,
        1.545e-02,1.585e-02,1.622e-02,1.657e-02,1.69e-02,1.719e-02,1.746e-02,1.77e-02,1.79e-02,1.807e-02,
        1.821e-02,1.832e-02,1.839e-02,1.842e-02,1.842e-02,1.839e-02,1.832e-02,1.821e-02,1.807e-02,1.79e-02,
        1.77e-02,1.746e-02,1.719e-02,1.69e-02,1.657e-02,1.622e-02,1.585e-02,1.545e-02,1.503e-02,1.459e-02,
        1.414e-02,1.367e-02,1.319e-02,1.269e-02,1.219e-02,1.168e-02,1.117e-02,1.065e-02,1.013e-02,9.618e-03,
        9.106e-03,8.599e-03,8.098e-03,7.605e-03,7.123e-03,6.652e-03,6.193e-03,5.748e-03,5.318e-03,4.904e-03,
        4.506e-03,4.126e-03,3.763e-03,3.419e-03,3.093e-03,2.785e-03,2.497e-03,2.227e-03,1.976e-03,1.744e-03,
        1.529e-03,1.332e-03,1.152e-03,9.882e-04,8.404e-04,7.079e-04,5.897e-04,4.852e-04,3.935e-04,3.137e-04,
        2.451e-04,1.868e-04,1.378e-04,9.748e-05,6.485e-05,3.913e-05,1.955e-05,5.326e-06
    };
    for (i=0;i<127;i++){
        sumnum += states[i]*znum[i];
        if (i<126) states[i] = states[i+1];
    }
    states[126] = invar;
    sumnum += states[126]*znum[127];
    return sumnum;
}

float DigFil(invar)
float invar;
/******************************************************************************/
/* Filter Solutions Version 2014                 Nuhertz Technologies, L.L.C. */
/*                                                            www.nuhertz.com */
/*                                                            +1 602-279-2448 */
/* 1st Order High Pass Butterworth                                            */
/* Bilinear Transformation with no Prewarping                                 */
/* Sample Frequency = 6.000 KHz                                               */
/* Standard Form                                                              */
/* Arithmetic Precision = 4 Digits                                            */
/*                                                                            */
/* Pass Band Frequency = 20.00 Hz                                             */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Input Variable Definitions:                                                */
/* Inputs:                                                                    */
/*   invar    float       The input to the filter                             */
/*                                                                            */
/* Option Selections:                                                         */
/* Standard C;   Not Initializable;        Internal States;   Optimized;      */
/*                                                                            */
/* There is no requirement to ever initialize the filter.                     */
/* The default initialization is zero when the filter is first called         */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* This software is automatically generated by Filter Solutions               */
/* no restrictions from Nuhertz Technologies, L.L.C. regarding the use and    */
/* distributions of this software.                                            */
/*                                                                            */
/******************************************************************************/

{
    float sumnum=0.0, sumden=0.0;  int i=0;
    static float states[1] = {0.0};
    static float znum[2] = {
        -.9896,
        .9896
    };
    static float zden[1] = {
        -.9793
    };
    sumnum = sumden = 0.0;
    sumden += states[0]*zden[0];
    sumnum += states[0]*znum[0];
    states[0] = invar-sumden;
    sumnum += states[0]*znum[1];
    return sumnum;
}



/* EXAMPLE
riff_header='RIFF',
wav_size=size of wave portion
wave_header="WAVE"
fmt_header="fmt"
fmt_chunk_size=16
audio_format=1
num_channels=1
sample_rate=44100
byte_rate=88200
sample_alignment=2
bit_depth=16
data_header="data"
data_bytes=15987456
*/
typedef struct wav_header {
    // RIFF Header
    char riff_header[4]; // Contains "RIFF"
    int wav_size; // Size of the wav portion of the file, which follows the first 8 bytes. File size - 8
    char wave_header[4]; // Contains "WAVE"
    
    // Format Header
    char fmt_header[4]; // Contains "fmt " (includes trailing space)
    int fmt_chunk_size; // Should be 16 for PCM
    short audio_format; // Should be 1 for PCM. 3 for IEEE Float
    short num_channels;
    int sample_rate;
    int byte_rate; // Number of bytes per second. sample_rate * num_channels * Bytes Per Sample
    short sample_alignment; // num_channels * Bytes Per Sample
    short bit_depth; // Number of bits per sample
    /////
   
    // Data
    char data_header[4]; // Contains "data"
    int data_bytes; // Number of bytes in data. Number of samples * num_channels * sample byte size
    // uint8_t bytes[]; // Remainder of wave file is bytes
} wav_header;

/* run this program using the console pauser or add your own getch, system("pause") or input loop */
 
unsigned int streamIIRFilter128_v2(unsigned int bitOfStream, unsigned int* pToOutBuffer);
unsigned int streamIIRFilter64_v2(unsigned int bitOfStream, unsigned int* pToOutBuffer);
void filter64_v3(unsigned long long bitStream, unsigned int* buffer);
void filter128_v3(unsigned long long bitStream, unsigned int* buffer);
void filter64_v4(unsigned long long bitStream, unsigned int* buffer);
void decimateBlock(unsigned int* input,   short* output, unsigned int outputSize);

void filter128OfBlock(unsigned char* inputStream, unsigned int* outputData,unsigned int bytesOfStreamPerBlock);
void filter64OfBlock(unsigned char* inputStream, unsigned int* outputData,unsigned int bytesOfStreamPerBlock);

int main(int argc, char *argv[]) {
	FILE* myAudioFile;
	FILE* templateFile;
	FILE* bitStreamFile;
	FILE* filteredFile;	
	wav_header audio_header;
	float fl1,fl2;
	
	unsigned long long bitStreamBuffer[256];
	unsigned int filteredBuffer[8200];
	unsigned short waveBuffer[8292];
	unsigned long long  *auxPtrToBitStream;
	unsigned int  *auxPtrToFilteredBuffer;
	//amount of 32bit words per block 
    const unsigned int intWordsPerBlock = 8192;
    //amount of 64bit words of bitstream per block 
    const unsigned int bsLongPerBlock = 128;
    //
    unsigned long long bitStreamLength;
    unsigned int wholeBsLongBlocks = 0;
    //bitStreamBuffer = malloc( (bsLongPerBlock*8));
    ////filteredBuffer  = malloc((intWordsPerBlock*4));
     unsigned int fastIntAudioDataLength;
	//open template of WAVE file header into structure
	templateFile = fopen("wav_header","rb");
	fread(&audio_header, sizeof(wav_header), 1, templateFile);
    fclose(templateFile);
    //---------------DBG-{
     
    //-------------------DBG-}
    //open bs file
    bitStreamFile = fopen("stream1.bin","rb");
    //read bitstream file size
    fseek(bitStreamFile,0,SEEK_END);
    bitStreamLength = ftell(bitStreamFile);
    fseek(bitStreamFile,0,SEEK_SET);
    //how many whole blocks contains a bs file
    wholeBsLongBlocks = bitStreamLength / (bsLongPerBlock << 3); //mult by 8 
    //open temporaty file
    filteredFile = fopen("filtered","wb");
    
    
		
	     
	for (int a1=0; a1<wholeBsLongBlocks; a1++) {
		//initializing auxialary pointers
	     auxPtrToBitStream = bitStreamBuffer;
	     auxPtrToFilteredBuffer = filteredBuffer;
		//reading all the bs file by blocks
		//1)read chunk into input buffer
		fread(bitStreamBuffer,bsLongPerBlock,8,bitStreamFile);
		//2)iterate the block and processing data
		for (int y1=0; y1<bsLongPerBlock; y1++) {
		      //a) processing 64bits of BS
			  	filter64_v4(*auxPtrToBitStream, auxPtrToFilteredBuffer);
			  //b)increment pointers
			  auxPtrToBitStream++;
			  auxPtrToFilteredBuffer += 64;
		}
		
		//3)Save results (block) into temp file
		fwrite(filteredBuffer,intWordsPerBlock, 4, filteredFile);
	}
	 	
	 //calculating amount of 32-bit words in high speed data 384kHz
	 fastIntAudioDataLength = intWordsPerBlock * wholeBsLongBlocks;
	
	fclose(filteredFile);
	//open again in read only mode
	filteredFile = fopen("filtered","rb");
	//create audio file
	myAudioFile = fopen("processed.wav","wb");

	audio_header.byte_rate = 12000;
	audio_header.sample_rate = 6000;
	audio_header.data_bytes = (fastIntAudioDataLength >> 5); // divided by 64 and divided by 2 (because 16bit wave)
	//write wave header
	fwrite(&audio_header, sizeof(wav_header),1,myAudioFile);
	
	for ( unsigned int k = 0; k < fastIntAudioDataLength; ) { 
		//1)read block into memory
		fread (filteredBuffer, intWordsPerBlock, 4, filteredFile);
		//1.1)post-filtering
		 auxPtrToFilteredBuffer = filteredBuffer;
		for (int a9=0; a9<intWordsPerBlock; a9++) {
			auxPtrToFilteredBuffer[a9] = (unsigned int) DigFil3K((float)auxPtrToFilteredBuffer[a9]);
		}
		//2)decimate block
		decimateBlock(filteredBuffer,waveBuffer, (intWordsPerBlock >> 6));
		//3) write block in wave file
		fwrite (waveBuffer,256,1,myAudioFile);
		k += intWordsPerBlock;
		
		
	}
	
	fclose(myAudioFile);
	fclose(filteredFile);
    ///free memory
    //free(bitStreamBuffer);
    //free(filteredBuffer);
	return 0;
}

void filter128OfBlock(unsigned char* inputStream, unsigned int* outputData,unsigned int bytesOfStreamPerBlock) {
	 
	unsigned char inByte=0;
	const char msk = 0x01;
	for (int a3=0; a3 < bytesOfStreamPerBlock; a3++) {
		inByte = *inputStream; 
		 
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			streamIIRFilter128_v2((unsigned int)(inByte & msk), outputData);
			inByte >>= 1;
			outputData++;
			
	 
		inputStream++;
	}
}

void filter64OfBlock(unsigned char* inputStream, unsigned int* outputData,unsigned int bytesOfStreamPerBlock) {
	unsigned int* ptr = outputData; 
	unsigned char inByte=0;
	const char msk = 0x01;
	for (int a3=0; a3 < bytesOfStreamPerBlock; a3++) {
		inByte = *inputStream; 
		for (int a4=0; a4<8; a4++ ) {
			streamIIRFilter64_v2((unsigned int)(inByte & msk), ptr);
			inByte >>= 1;
			ptr++;
		}
		inputStream++;
	}
}

void decimateBlock(unsigned int* input,   short* output, unsigned int outputSize){
	float sample;
   for(;outputSize > 0;){
   	sample = (float)*input;
   	
  	*output = (short) DigFil(sample);
  	input += 64;
  	output++;
  	if(outputSize & 1 ){
  		
	  }
  	outputSize--;
  }
}
//{{{{{{{{{{{
/**the filter get a chunk (64bit) of bit stream
 and store result (each bit) into 32bit array**/ 
void filter64_v4 (unsigned long long bitStream, unsigned int* buffer) {
	
	unsigned long long bitToProcess = 0;
	unsigned long long mask = 1;
	float acc = 0;
	static unsigned long long window = 0; 
	short idx = 0;
		const float coefs[]={
		    76.530036926, 
			152.881332397, 
			228.875564575,
			304.335266113, 
			379.084167480, 
			452.947692871, 
			525.753356934, 
			597.331054688, 
			667.513671875, 
			736.137268066, 
			803.041625977, 
			868.070434570,
			931.071838379, 
			991.898681641, 
			1050.408935547, 
			1106.465942383, 
			1159.938598633, 
			1210.702270508, 
			1258.638305664, 
			1303.634643555, 
			1345.586303711, 
			1384.395263672, 
			1419.970947266, 
			1452.230102539, 
			1481.097656250, 
			1506.506103516, 
			1528.395874023, 
			1546.716064453, 
			1561.423828125, 
			1572.484619141, 
			1579.873168945, 
			1583.571533203, 
			1583.571533203, 
			1579.873046875, 
			1572.484497070, 
			1561.423583984, 
			1546.715820313, 
			1528.395507813, 
			1506.505615234, 
			1481.097290039,
			1452.229614258, 
			1419.970458984, 
			1384.394653320, 
			1345.585571289, 
			1303.633911133, 
			1258.637451172, 
			1210.701416016, 
			1159.937744141, 
			1106.464965820, 
			1050.407958984, 
			991.897705078, 
			931.070800781, 
			868.069396973, 
			803.040527344, 
			736.136169434, 
			667.512451172, 
			597.329772949, 
			525.752014160, 
			452.946289063, 
			379.082702637, 
			304.333770752, 
			228.874038696, 
			152.879760742, 
            76.528419495
		};
	
	for (int bitCount=0; bitCount < 64; bitCount++) {
		//extracting low bit
	     bitToProcess = bitStream & 1;	
	     //shifting window
		window <<= 1;
		//apply new bit
	    window |= bitToProcess;
	    mask = 1;
	    idx = 0;
		acc = 0;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
				if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
				if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
				if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
				if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
				if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		//store result
		*buffer = acc;;
		//increment pointer (to point to next word)
		buffer++;
	
		//shift BitStr to have next bit al low bit for processing
		bitStream >>= 1;
	}
	   
	 
}
//}}}}}}}
/**the filter get a chunk (64bit) of bit stream
 and store result (each bit) into 32bit array**/ 
void filter64_v3(unsigned long long bitStream, unsigned int* buffer){
	
	unsigned long long bitToProcess = 0;
	unsigned long long mask = 1;
	unsigned int acc =0;
	static unsigned long long window = 0; 
	short idx = 0;
		const unsigned int coefs[]={24,36,49,66,85,106,131,159,189,222,258,297,338,381,
	426,472,519,567,615,662,709,753,796,836,874,907,937,963,983,999,1010,1015,1015,
	1010,999,983,963,937,907,874,836,796,753,709,662,615,567,519,472,426,381,338,297,
	258,222,189,159,131,106,85,66,49,36,24};
	
	for (int bitCount=0; bitCount < 64; bitCount++) {
		//extracting low bit
	     bitToProcess = bitStream & 1;	
	     //shifting window
		window <<= 1;
		//apply new bit
	    window |= bitToProcess;
	    mask = 1;
	    idx = 0;
		acc = 0;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
				if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
				if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
				if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
				if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
				if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		if (window & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		//store result
		*buffer = acc;;
		//increment pointer (to point to next word)
		buffer++;
	
		//shift BitStr to have next bit al low bit for processing
		bitStream >>= 1;
	}
	   
	 
}

/**the filter get a chunk (64bit) of bit stream
 and store result (each bit) into 32bit array**/ 
void filter128_v3(unsigned long long bitStream, unsigned int* buffer){
	
	unsigned long long bitToProcess = 0;
	unsigned long long mask = 1;
	unsigned int acc =0;
	unsigned long long carry = 0;
	static unsigned long long windowLow = 0;
	static unsigned long long windowHigh = 0; 
	short idx = 0;
const unsigned int coefs[128]={1,2,4,6,8,11,14,17,21,26,31,37,44,52,61,71,82,94,108,122,
		138,156,174,194,216,238,262,287,313,341,369,399,430,461,493,526,560,594,628,663,697,
		732,767,801,834,868,900,931,962,991,1019,1046,1071,1094,1116,1136,1153,1169,1183,
		1195,1204,1210,1216,1218,1218,1216,1210,1204,1195,1183,1169,1153,1136,1116,1094,
		1071,1046,1019,991,962,931,900,868,834,801,767,732,697,663,628,594,560,526,493,
		461,430,399,369,341,313,287,262,238,216,194,174,156,138,122,108,94,82,71,61,52,
		44,37,31,26,21,17,14,11,8,6,4,2,1 };
	
	for (int bitCount=0; bitCount < 64; bitCount++) {
		//extracting low bit
	     bitToProcess = bitStream & 1;	
		//extracting high bit from low word
		carry = windowLow & 0x8000000000000000;
		carry >>= 63;
		//shift, apply to  high word 
		windowHigh <<= 1;
		windowHigh |= carry;
		//shift low window and apply bit from bit stream 
		windowLow <<= 1;
		windowLow |= bitToProcess;

	    mask = 1;
	    idx = 0;
		acc = 0;
		if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
			if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowLow & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		///////////high word
		mask=1;
			if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
	if (windowHigh & mask) {
			acc +=coefs[idx];
		};
		mask <<= 1;
		idx++;
		//store result
		*buffer = acc;
		//increment pointer (to point to next word)
		buffer++;
///???????????????????????????????????????????????????????????????????
		//shift BitStr to have next bit al low bit for processing
		bitStream >>= 1;
	}
	   
	 
}
 
 

/* 128 Tap Low Pass Kaiser                                                 
  Finite Impulse Response                                                     
  Sample Frequency = 384.0 KHz                                                
  Standard Form                                                               
  Arithmetic Precision = 4 Digits                                                                                                                          
  Pass Band Frequency = 3.000 KHz  */

unsigned int streamIIRFilter64_v2(unsigned int bitOfStream, unsigned int* pToOutBuffer){

	static unsigned long long bits = {0};
	unsigned int result=0;
	unsigned long long bitMask = 1;
 
	const unsigned int coefs[]={24,36,49,66,85,106,131,159,189,222,258,297,338,381,
	426,472,519,567,615,662,709,753,796,836,874,907,937,963,983,999,1010,1015,1015,
	1010,999,983,963,937,907,874,836,796,753,709,662,615,567,519,472,426,381,338,297,
	258,222,189,159,131,106,85,66,49,36,24};
	
		bitOfStream &= 0x00000001;
	    bits 	<<= 1;
	    bits |= bitOfStream;
	    for (int a=0; a<64; a++) {
		 
	    	if (bitMask & bits) {
	            result += coefs[a];		
			}
			bitMask <<= 1;
		}
		
		*pToOutBuffer = result;
		
		//printf("%X, %X \n",bits[0], bits[1]);
	//	printf("%d \n", result);
		
}

//converts bit-stream into 32-bit integer chunk of data
//This function save previous results in an static array
/* 128 Tap Low Pass Hamming                                                   
  Finite Impulse Response                                                     
  Sample Frequency = 384.0 KHz                                                
  Standard Form                                                               
  Arithmetic Precision = 4 Digits                                                                                                                          
  Pass Band Frequency = 3.000 KHz  */
  //sum all the coefs equals 65534
unsigned int streamIIRFilter128_v2(unsigned int bitOfStream, unsigned int* pToOutBuffer) {
	
	static unsigned long long bits0 = 0;
	static unsigned long long bits1 = 0;
	unsigned int counterIndex = 0;
	unsigned long long state = 0;
	
	unsigned int result=0;
	const unsigned int coefs[128]={1,2,4,6,8,11,14,17,21,26,31,37,44,52,61,71,82,94,108,122,
		138,156,174,194,216,238,262,287,313,341,369,399,430,461,493,526,560,594,628,663,697,
		732,767,801,834,868,900,931,962,991,1019,1046,1071,1094,1116,1136,1153,1169,1183,
		1195,1204,1210,1216,1218,1218,1216,1210,1204,1195,1183,1169,1153,1136,1116,1094,
		1071,1046,1019,991,962,931,900,868,834,801,767,732,697,663,628,594,560,526,493,
		461,430,399,369,341,313,287,262,238,216,194,174,156,138,122,108,94,82,71,61,52,
		44,37,31,26,21,17,14,11,8,6,4,2,1 };
		bitOfStream &= 0x00000001;
		
		//1) shifting high word
		bits1 <<= 1;
		//2)Is the MSB in low word = 1  ?
		 state  = bits0 & 0x8000000000000000; //extract MSB
		 state >>= 63; //move to LSB
		 bits1 |= state; //apply to high word
		 //3) shft low word and apply input bit-stream
		 bits0 <<= 1;
		 bits0 |= bitOfStream;
		//processing first 64bits
	 
		state = 1;
		for (int a=0; a<64; a++) {
	    	if (state & bits0) {
	            result += coefs[counterIndex];		
			}
			state <<= 1;
			counterIndex++;
		}
		//processing last 64bit
		state = 1;
		for (int b=0; b<64; b++) {
		 
	    	if (state & bits1) {
	            result += coefs[counterIndex];		
			}
			state <<= 1;
			counterIndex++;
		}
		
		*pToOutBuffer = result;
		
	 //	printf("%d \n", result );
//	printf("%llx, %llx \n",bits0,bits1);
		
}
